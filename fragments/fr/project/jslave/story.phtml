<?php
require_once 'fragment.php';
$f = start('fr') ?>
<p>Un langage pour définir des <q>blueprints</q> déclaratifs pour générer des classes <?= $f->def('java') ?>.</p>
<p>Prend en charge la génération automatique et personnalisable de&nbsp;:</p>
<ul class="list">
    <li>
        <p>Arborescences d'héritage (<code>extend</code>, <code>implement</code>, <code>permits</code>)</p>
    </li>
    <li>
        <p>Attributs</p>
    </li>
    <li>
        <p><?= $f->term('Getters', 'en', 'Obteneurs') ?>/<?= $f->term('setters', 'en', 'Définisseurs') ?></p>
    </li>
    <li>
        <p>méthode <code>hashCode</code></p>
    </li>
    <li>
        <p>méthode <code>equals</code></p>
    </li>
    <li>
        <p>méthode <code>toString</code></p>
    </li>
    <li>
        <p>Stubs de méthode</p>
    </li>
</ul>
<p>Fonctionnalités supplémentaires&nbsp;:</p>
<ul class="list">
    <li>
        <p>Classes imbriquées et statiques</p>
    </li>
    <li>
        <p>Blocs de code Java arbitraires</p>
    </li>
</ul>
<article>
    <h3 id="avantages-sur-les-extraits">Avantages par rapport aux extraits</h3>
    <p>Un blueprint Jslave est autonome et peut être automatisé, contrairement aux extraits/raccourcis qui dépendent de l'IDE et nécessitent une saisie manuelle. Cette approche présente les avantages suivants&nbsp;:</p>
    <ul class="list">
        <li>
            <p>Les blueprints peuvent être transmis sous forme de fichiers</p>
        </li>
        <li>
            <p>Les blueprints peuvent être générés vers autre chose que Java</p>
        </li>
        <li>
            <p>La génération est prévisible et déterministe</p>
        </li>
        <li>
            <p>La génération peut être automatisée dans un script</p>
        </li>
    </ul>
    <p>Inconvénients&nbsp;:</p>
    <ul class="list">
        <li>
            <p>Étant donné que nous ne sommes plus dans un contexte Java, nous ne recevrons pas beaucoup d'aide de l'IDE lors de l'écriture de JSlave (coloration syntaxique, auto-complétion&hellip;). Ce problème est atténué par la simplicité du langage et la future extension <?= $f->def('vs-code') ?>.</p>
        </li>
    </ul>
</article>
<article>
    <h3 id="getting-started">Premiers pas</h3>
    <h4 id="1-write-your-jslave-file">1. Écrivez votre fichier JSlave</h4>
    <p>Votre fichier JSlave (appelé idiomatiquement un <strong>blueprint</strong>) définit la structure de votre code Java et fournit la syntaxe des modèles courants afin d'éviter d'écrire tout ce code Java répétitif.</p>
    <p>Vous trouverez plus de détails sur la syntaxe dans la <?= $f->blank('documentation', 'https://github.com/5cover/jslave/blob/main/doc/Language%20reference.md') ?>, mais l'idiome principal est le suivant&nbsp;:</p>
    <p>Un blueprint est une liste de <strong>définitions</strong> qui génèrent le type Java correspondant (classes, enregistrements, interfaces&hellip;). Chaque définition contient zéro ou plusieurs <strong>membres</strong> qui déterminent le contenu du type.</p>
    <p>Les membres peuvent être de deux types&nbsp;:</p>
    <ul class="list">
        <li>
            <p><strong>Les attributs</strong> définissent les champs de données du type. Ils génèrent des attributs de classe Java et des méthodes getter/setter.</p>
        </li>
        <li>
            <p><strong>Les méthodes</strong> définissent les comportements du type. Les méthodes qui ont une signification particulière en Java (<code>equals</code>, <code>hashCode</code>, <code>toString</code>) sont appelées <strong>méthodes spéciales</strong>. Elles peuvent être exprimées sous trois formes&nbsp;:</p>
            <ul class="list">
                <li>
                    <p><strong>Stub</strong>&nbsp;: une méthode vide à implémenter soit à partir du code Java généré, soit avec un bloc de code</p>
                </li>
                <li>
                    <p><strong>Implémentation par défaut</strong>&nbsp;: une implémentation par défaut à usage général qui devrait fonctionner dans la plupart des cas</p>
                </li>
                <li>
                    <p><strong>Implémentation personnalisée</strong>&nbsp;: l'implémentation par défaut, personnalisée en passant des arguments à la méthode</p>
                </li>
            </ul>
        </li>
    </ul>
    <h4 id="2-generate-it">2. Générez-le</h4>
    <p>À partir de l'interface graphique de l'extension VSCode ou en utilisant le binaire autonome, générez votre blueprint.</p>
    <p>Plusieurs cibles sont disponibles</p>
    <ul class="list">
        <li>
            <p><?= $f->def('java') ?> (évidemment)&nbsp;: génère du code Java</p>
        </li>
        <li>
            <p><?= $f->def('mermaid') ?>&nbsp;: génère un diagramme de classe Mermaid<?= $f->ref() ?> représentant la structure du blueprint</p>
        </li>
    </ul>
</article>