<?php
require 'fragment.php';
define('LANG', 'fr');
?>
<p>Psdc répond à un besoin. Celui d'automatiser la tâche fastidieuse de traduire des programmes entre différents langages de programmation.</p>
<p>Au cours de ma formation de BUT Informatique, j'ai appris l'algorithmie avec le Pseudocode, un pseudolangage de programmation inventé pour les besoins de l'IUT de Lannion. Inspiré du <?php definition(LANG, 'pascal') ?>, le Pseudocode permet d'énoncer un algorithme dans un langage plus proche de celui de l'homme que de celui de l'ordinateur, tout en gardant l'aspect exhaustif de tout langage de programmation.</p>
<p>Au cours de nos TP, nous avons très souvent dû traduire des programmes en pseudocode vers le C. Cette tâche est assez réberbative, d'où mon désir de l'automatiser. Et c'est ce qui ma mené à découvrir la conception de compilateurs.</p>
<p>À titre d'exemple, voici un simple programme en pseudocode qui affiche "Bonjour" à l'écran&nbsp;:</p>
<pre><code>programme Afficher Bonjour c'est début
    écrireÉcran("Bonjour");
fin</code></pre>
<p>Voici un programme équivalent en C&nbsp;:</p>
<pre><code>#include &lt;stdio.h&gt;

int main() {
    printf("Bonjour\n");
    return 0;
}</code></pre>
<p>Comment automatiser cette transformation&nbsp;? Et bien, en réalité, ce n'est pas si complexe. Le livre Crafting Interpreters<?php reference() ?> métaphorise le problème par l'ascension d'une montagne&nbsp;:</p>
<figure class="figure"><img alt="Métaphore de la montagne" src="/portfolio/img/project/psdc/mountain.png" width="1824" height="833" loading="lazy">
    <figcaption>Robert Nystrom &mdash; &copy; 2015 &ndash; 2021, license MIT</figcaption>
</figure>
<p>Commencons avec le code source original, au pied de la montagne. Au fil des étapes (<em>scanning</em>, <em>parsing</em>, <em>analysis</em>), la représentation du code devient de plus en plus haut niveau, c'est-à-dire qu'elle se focalise plus sur la sémantique exprimée que sur les détails d'implémentation.</p>
<p>Une fois le sommet atteint, on est à mi-chemin de la compilation. On a une vue imprenable sur la sémantique du code, soit le sens que l'utilisateur lui donne à travers la syntaxe de notre langage.</p>
<p>Alors entamons notre descente. Convertissons successivement notre représentation de haut niveau en des formes se rapprochant de notre objectif final&nbsp;: le langage machine, qui sera exécuté directement par le processeur.</p>
<p>Je n'ai découvert Crafting Interpreters qu'assez tard dans le projet. À l'origine, je me suis basé sur la playlist Creating a Compiler<?php reference() ?> de <?php link_blank("Pixeled", "https://www.youtube.com/@pixeled-yt") ?> sur YouTube, où l'on assiste à la conception et à l'implémentation d'un compilateur pour un language <em>ex-nihilo</em> nommé Hydrogen. Le compilateur transforme le code en assembleur, puis utilise NASM<?php reference() ?> pour générer le code machine.</p>
<p>C'est dans ces vidéos que j'ai appris les bases de l'analyse lexicale<?php reference() ?>, des grammaires formelles<?php reference() ?>, ou encore de l'analyse syntaxique<?php reference() ?>. C'est vraiment intéressant et j'apprends beaucoup de choses.</p>