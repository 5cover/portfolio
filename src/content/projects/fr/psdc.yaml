{
  "id": "psdc",
  "lang": "fr",
  "title": "Psdc",
  "abstract": "Compilateur pseudocode de l'IUT de Lannion",
  "story": "\n<p>Psdc répond à un besoin. Celui d'automatiser la tâche fastidieuse de traduire des programmes entre différents langages de programmation.</p>\n<p>Au cours de ma formation de BUT Informatique, j'ai appris l'algorithmie avec le Pseudocode, un pseudolangage de programmation inventé pour les besoins de l'IUT de Lannion. Inspiré du <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://fr.wikipedia.org/wiki/Pascal_(langage)\" data-definition-id=\"pascal\" class=\"link definition-tooltip-trigger\">Pascal</a>, le Pseudocode permet d'énoncer un algorithme dans un langage plus proche de celui de l'homme que de celui de l'ordinateur, tout en gardant l'aspect exhaustif de tout langage de programmation.</p>\n<p>Au cours de nos TP, nous avons très souvent dû traduire des programmes en pseudocode vers le <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://fr.wikipedia.org/wiki/C_(langage)\" data-definition-id=\"c\" class=\"link definition-tooltip-trigger\">C</a>. Cette tâche est assez réberbative, d'où mon désir de l'automatiser. Et c'est ce qui ma mené à découvrir la conception de compilateurs.</p>\n<p>À titre d'exemple, voici un simple programme en pseudocode qui affiche <q>Bonjour</q> à l'écran&nbsp;:</p>\n<pre><code>programme AfficherBonjour c&#39;est début\n    écrireÉcran(&quot;Bonjour&quot;);\nfin</code></pre>\n<p>Voici un programme équivalent en C&nbsp;:</p>\n<pre><code>#include &lt;stdio.h&gt;;\n\nint main() {\n    printf(&quot;Bonjour\\\\n&quot;);\n    return 0;\n}</code></pre>\n<p>Comment automatiser cette transformation&nbsp;? Et bien, en réalité, ce n'est pas si complexe. Le livre Crafting Interpreters<sup id=\"cite-ref-1\"><a class=\"link\" href=\"#ref-1\">[1]</a></sup> métaphorise le problème par l'ascension d'une montagne&nbsp;:</p>\n<figure class=\"figure\">\n    <img alt=\"Métaphore de la montagne\" src=\"/portfolio/img/projects/psdc/mountain.png\" width=\"1824\" height=\"833\" loading=\"lazy\">\n    <figcaption><cite>Crafting Interpreters</cite>, Robert Nystrom &mdash; &copy; <time datetime=\"2015\">2015</time> &ndash; <time datetime=\"2021\">2021</time>, license MIT</figcaption>\n</figure>\n<p>Commençons avec le code source original, au pied de la montagne. Au fil des étapes (<em lang=\"en\">scanning</em>, <em lang=\"en\">parsing</em>, <em lang=\"en\">analysis</em>), la représentation du code devient de plus en plus haut niveau, c'est-à-dire qu'elle se focalise plus sur la sémantique exprimée que sur les détails d'implémentation.</p>\n<p>Une fois le sommet atteint, on est à mi-chemin de la compilation. On a une vue imprenable sur la sémantique du code, soit le sens que l'utilisateur lui donne à travers la syntaxe de notre langage.</p>\n<p>Alors entamons notre descente. Convertissons successivement notre représentation de haut niveau en des formes se rapprochant de notre objectif final&nbsp;: le langage machine, qui sera exécuté directement par le processeur.</p>\n<p>Je n'ai découvert Crafting Interpreters qu'assez tard dans le projet. À l'origine, je me suis basé sur la playlist <em lang=\"en\">Creating a Compiler</em><sup id=\"cite-ref-2\"><a class=\"link\" href=\"#ref-2\">[2]</a></sup> de <a class=\"link\" target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://www.youtube.com/@pixeled-yt\">Pixeled</a> sur YouTube, où l'on assiste à la conception et à l'implémentation d'un compilateur pour un language <em>ex-nihilo</em> nommé Hydrogen. Le compilateur transforme le code en assembleur, puis utilise <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://fr.wikipedia.org/wiki/Netwide_Assembler\" data-definition-id=\"nasm\" class=\"link definition-tooltip-trigger\">NASM</a> pour générer le code machine.</p>\n<p>C'est dans ces vidéos que j'ai appris les bases de l'analyse lexicale<sup id=\"cite-ref-3\"><a class=\"link\" href=\"#ref-3\">[3]</a></sup>, des grammaires formelles<sup id=\"cite-ref-4\"><a class=\"link\" href=\"#ref-4\">[4]</a></sup>, ou encore de l'analyse syntaxique<sup id=\"cite-ref-5\"><a class=\"link\" href=\"#ref-5\">[5]</a></sup>. C'est vraiment intéressant et j'apprends beaucoup de choses.</p>\n<p>Ce projet est loin d'être terminé &mdash; de nombreuses fonctionnalités restent à implémenter, notamment pour l'intégration <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://fr.wikipedia.org/wiki/Visual_Studio_Code\" data-definition-id=\"vs-code\" class=\"link definition-tooltip-trigger\">VS Code</a> avec serveur de langage.</p>",
  "context": "Personnel",
  "startDate": "2023-11-15",
  "endDate": null,
  "tags": [
    "software",
    "oop",
    "compiler",
    "but-realiser",
    "but-optimiser",
    "cli"
  ],
  "technologies": [
    "csharp",
    "ebnf",
    "vs-code",
    "markdown"
  ],
  "team": [],
  "links": [
    {
      "label": "Dépôt GitHub",
      "anchor": "github",
      "href": "https://github.com/5cover/psdc"
    }
  ],
  "references": [
    {
      "caption": "Analyse lexicale, Wikipédia",
      "anchor": "wikipedia",
      "href": "https://fr.wikipedia.org/wiki/Analyse_lexicale"
    },
    {
      "caption": "Analyse syntaxique, Wikipédia",
      "anchor": "wikipedia",
      "href": "https://fr.wikipedia.org/wiki/Analyse_syntaxique"
    },
    {
      "caption": "Crafting Interpreters, Robert Nystrom (anglais)",
      "anchor": "website",
      "href": "https://craftinginterpreters.com"
    },
    {
      "caption": "Creating a Compiler, Pixeled, sur YouTube (anglais)",
      "anchor": "youtube",
      "href": "https://www.youtube.com/playlist?list=PLUDlas_Zy_qC7c5tCgTMYq2idyyT241qs"
    },
    {
      "caption": "Grammaire formelle, Wikipédia",
      "anchor": "wikipedia",
      "href": "https://fr.wikipedia.org/wiki/Grammaire_formelle"
    }
  ],
  "gallery": [
    {
      "caption": "Poster / Infographie",
      "url": null,
      "iframeSrc": "/portfolio/img/projects/psdc/poster.pdf",
      "content": null
    }
  ],
  "logo": null,
  "background": "/portfolio/img/projects/psdc/bg.png"
}
