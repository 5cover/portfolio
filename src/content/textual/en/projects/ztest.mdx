
<p>For a long time, I had been intrigued by <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Zig_(programming_language)" data-definition-id="zig" class="link definition-tooltip-trigger">Zig</a>, a programming language that promised to address some of the shortcomings of <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/C_(programming_language)" data-definition-id="c" class="link definition-tooltip-trigger">C</a> while offering fresh perspectives on low-level programming. I decided to dive in and create a project that would not only help me learn Zig but also provide a practical application of the language. Thus, **ztest** was born &mdash; a Zig implementation of the Unix `test` command.</p>
<h3 id="the-challenge">The Challenge</h3>
<p>One of the most daunting tasks in this project was parsing the arguments. Unlike parsing a single string, I had to handle a list of arguments passed to the program, each of which was a string. Designing a robust parser with effective error handling was a significant hurdle.</p>
<h3 id="reverse-engineering-the-original">Reverse Engineering the Original</h3>
<p>To understand the intricacies of argument parsing, I delved into the official `test` implementation, which is written in C. The source code<sup id="cite-ref-1"><a class="link" href="#ref-1">[1]</a></sup> provided valuable insights that the man page lacked. Reverse engineering the original implementation helped me grasp the nuances of how arguments are processed.</p>
<h3 id="writing-unit-tests">Writing Unit Tests</h3>
<p>To ensure the reliability of my implementation, I wrote about 50 unit tests using Zig's built-in `test` syntax. These tests were based on the official test suite, which is written in Perlâ€”a language I am not familiar with. Despite this, I managed to translate the test cases effectively, ensuring that my implementation was robust and accurate.</p>
<h3 id="impressions-of-zig">Impressions of Zig</h3>
<p>Overall, I was thoroughly impressed by Zig. Its syntax is intuitive and consistent, making it easy to pick up. The concepts are straightforward, without being overly dogmatic or coercive (unlike <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Rust_(programming_language)" data-definition-id="rust" class="link definition-tooltip-trigger">Rust</a>'s borrow checker or <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/C%2B%2B" data-definition-id="cpp" class="link definition-tooltip-trigger">C++</a>'s rule of 5). Zig's simplicity and flexibility make it a valuable addition to my toolbox for future, more <q>real</q> projects.</p>
<h3 id="the-build-system">The Build System</h3>
<p>One of the standout features of Zig is its build system. Gone are the days of <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Make_(software)" data-definition-id="make" class="link definition-tooltip-trigger">Makefile headaches</a>. Zig's build system is user-friendly, making the development process smoother and more enjoyable.</p>
<h3 id="lessons-learned">Lessons Learned</h3>
<p>This project was a fantastic learning experience. It not only deepened my understanding of Zig but also honed my skills in argument parsing, reverse engineering, and writing unit tests. The challenges I faced and the solutions I devised have equipped me with valuable knowledge that I can apply to future projects.</p>
<p>**ztest** is more than just a project; it's a testament to the power of curiosity and the joy of learning. I'm excited to see where my journey with Zig takes me next.</p>
