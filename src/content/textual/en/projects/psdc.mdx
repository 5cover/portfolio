<p>Psdc meets a need. That of automating the tedious task of translating programs between different programming languages.</p>
<p>During my BUT Informatique training, I learned algorithms with Pseudocode, a pseudo programming language invented for the needs of the IUT of Lannion. Inspired from <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Pascal_(programming_language)" data-def-id="pascal" class="link def-tooltip-trigger">Pascal</a>, Pseudocode allows an algorithm to be stated in a language closer to that of humans than to that of computers, while keeping the exhaustive aspect of any programming language.</p>
<p>During our practical work, we very often had to translate pseudocode programs to <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/C_(programming_language)" data-def-id="c" class="link def-tooltip-trigger">C</a>. This task is quite daunting, hence my desire to automate it. And that's what led me to discover compiler design.</p>
<p>As an example, here's a simple pseudocode program that prints <q>Hello</q> to the screen:</p>
```psc
programme AfficherBonjour c'est début
    écrireÉcran("Hello");
fin
```
<p>Here is an equivalent program in C:</p>
```psc
#include <stdio.h>;

int main() {
printf("Bonjour\\n");
return 0;
}

```
<p>How do you automate this transformation? Well, it's actually not that complex. The Crafting Interpreters book<sup id="cite-ref-1"><a class="link" href="#ref-1">[1]</a></sup> metaphorizes the problem as climbing a mountain:</p>
<figure class="figure"><img alt="Mountain Metaphor" src="/portfolio/img/projects/psdc/mountain.png" width="1824" height="833" loading="lazy"/>
    <figcaption><cite>Crafting Interpreters</cite>, Robert Nystrom &mdash; &copy; <time datetime="2015">2015</time> &ndash; <time datetime="2021">2021</time>, MIT license</figcaption>
</figure>
<p>Let's start with the original source code, at the foot of the mountain. As the steps go by (scanning, parsing, analysis), the representation of the code becomes more and more high-level, that is, it focuses more on the expressed semantics than on implementation details.</p>
<p>Once the top is reached, we are halfway through the compilation. We have a breathtaking view of the semantics of the code, that is, the meaning that the user gives it through the syntax of our language.</p>
<p>So let's begin our descent. Let's successively convert our high-level representation into forms that approximate our final goal: the machine language, which will be executed directly by the processor.</p>
<p>I only discovered Crafting Interpreters quite late in the project. I originally based it on the playlist <em lang="en">Creating a Compiler</em><sup id="cite-ref-2"><a class="link" href="#ref-2">[2]</a></sup> by <a class="link" target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/@pixeled-yt">Pixeled</a> on YouTube, where we see the design and implementation of a compiler for a language *ex-nihilo* called Hydrogen. The compiler transforms the code into assembly, then uses <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Netwide_Assembler" data-def-id="nasm" class="link def-tooltip-trigger">NASM</a> to generate the machine code.</p>
<p>It is in these videos that I learned the basics of lexical analysis<sup id="cite-ref-3"><a class="link" href="#ref-3">[3]</a></sup>, formal grammars<sup id="cite-ref-4"><a class="link" href="#ref-4">[4]</a></sup>, or syntactic analysis<sup id="cite-ref-5"><a class="link" href="#ref-5">[5]</a></sup>. It is really interesting and I've learned a lot.</p>
<p>This project is far from being done &mdash; many features are yet to implemented, notably for <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Visual_Studio_Code" data-def-id="vs-code" class="link def-tooltip-trigger">VS Code</a> integration with a language server.</p>
```
